print(a)
}
# testing the function
expo(2,100)
# This is the list.files function
list.files()
# let's see what the function needs
?list.files
# We want to see what csvs we have in our data folder
list.files(path="data", pattern="csv")
# Note that we can just use "data" because the data folder is in the
# same folder as this script
# we can also use this for file names, not just types
file_names <- list.files(path = "data", pattern = "inflammation")
# We can use this to load files from the results!
read.csv(file_names[1], header = FALSE)
# We can use the full.names argument set to TRUE to get the full path instead
file_names <- list.files(path = "data", pattern = "inflammation", full.names = TRUE)
head(read.csv(file_names[1], header=FALSE))
file_names <- list.files(path = "data",
pattern = "inflammation[0-9]{2}.csv",
full.names = TRUE)
# We can now use this to plot all of the avg values for each inflammation file
for (name in file_names) {
print(name)
# We use the function we copied from the start
analyze(name)
}
for (apple in grape)
{print(apple)}
grape <- c("gra", "pe")
for (apple in grape)
{print(apple)}
apple
odds <- c(1,3,5,7,9)
for (b in odds) {
even <- b + 1
print(even)
}
for (b in odds) {
even <- b + 1
print(even)
}
odds <- c(1,3,5,7,9, 11, 13, 15, 17)
for (b in odds) {
even <- b + 1
print(even)
}
data <- read.csv(file_names[1], header=FALSE)
data <- read.csv("data/inflammatio-01.csv", header=FALSE)
data <- read.csv("data/inflammation-01.csv", header=FALSE)
for (row in data) {
print (row)
}
for (row in data$V1) {
print (row)
}
analyze_all <- function(folder, pattern){
# This function uses the analyze function to plot all datasets in the given
# folder location that match the given pattern
filenames <- list.files(path = folder,
pattern = pattern,
full.names = TRUE)
for (name in filenames) {
print(name) # check that all files are covered
data <- read.csv(file = name, header = FALSE)
avg_patient_inflammation <- apply(data, 2, mean)
min_patient_inflammation <- apply(data, 2, min)
max_patient_inflammation <- apply(data, 2, max)
plot(avg_patient_inflammation)
plot(min_patient_inflammation)
plot(max_patient_inflammation)
}
}
analyze_all("data", "inflammation")
pdf("inflammation-01.pdf")
# commands that follow will be entered into our pdf
analyze("data/inflammation-01.csv")
# Check the files window in the bottom right, you'll see the pdf exists there now
# To stop this again we use the dev.off command
dev.off
pdf("inflammation-01.pdf")
# commands that follow will be entered into our pdf
analyze("data/inflammation-01.csv")
# We will quickly take a look at how to use the pdf function, in case we want
# to export work to pdf
?pdf
# Check the files window in the bottom right, you'll see the pdf exists there now
# To stop this again we use the dev.off command
dev.off()
num <- 37
num <100
num >100
# Logic in R
# Logic is needed a lot in writing code
# We can start with the less than and greater than symbols
num <- 37
num < 100
num > 100
num <- 37
if (num > 100) {
print("greater")
} else {
print("not greater")
}
# note that an else is the end here, to use another else requires another if
# however, an if does not require an else statement
sign <- function (num) {
if (num > 0){
return (1)
} else if (num == 0) {
return (0)
} else {
return (-1)
}
}
# note that we use "==" in the else if, that is used when we make a logic check
# the "==" is a check that num and 0 are equal to each other
# testing the function
sign(3)
> # greater than
plot_dist <- function(x, threshold) {
if (length(x) > threshold) {
boxplot(x)
} else {
stripchart(x)
}
}
plot_dist(c(1,2,3,4,4), 4)
plot_dist <- function(x, threshold) {
if (length(x) > threshold) {
print("longer")
boxplot(x)
} else {
print("shorter")
stripchart(x)
}
}
plot_dist(c(1,2,3,4,4), 4)
boxplot(c(1,2,24,4,5))
?boxplot
boxplot(c(1,2,24,4,5))
dev.off()
boxplot(c(1,2,24,4,5))
plot_dist <- function(x, threshold) {
if (length(x) > threshold) {
print("longer")
boxplot(x)
} else {
print("shorter")
stripchart(x)
}
}
plot_dist(c(1,2,3,4,4), 4)
boxplot(c(1,2,24,4,5))
dev?boxplot
plot_dist(c(3,4,555,6), 10)
file_names <- list.files(path = "data",
pattern = "inflammation",
full.names = TRUE)
# Setting our initial values, ready to be overwritten
file_name_max <- ""
patient_max <- 0
average_inf_max <- 0
for (f in file_names) {
dat <- read.csv(file = f, header = FALSE)
dat_means = apply(dat, 1 mean) # Applying the mean function per row
file_names <- list.files(path = "data",
pattern = "inflammation",
full.names = TRUE)
# Setting our initial values, ready to be overwritten
file_name_max <- ""
patient_max <- 0
average_inf_max <- 0
for (f in file_names) {
dat <- read.csv(file = f, header = FALSE)
dat_means = apply(dat, 1, mean) # Applying the mean function per row
# We loop over index values in the range from 1 to the length of dat_means
# We check each patient and look for the maximum average inflammation
# We check all patients keeping the index and file name where the largest
# Average inflammation is
for(patient_index in 1:length(dat_means)) {
patient_average_inf <- dat.means[patient_index]
if (patient_average_inf > average_inf_max) {
average_inf_max <- patient_average_inf
patient_max <- patient_index
file_name_max <- f
}
}
}
# Logic in R
# Logic is needed a lot in writing code
# We can start with the less than and greater than symbols
num <- 37
num < 100
num > 100
num <- 37
if (num > 100) {
print("greater")
} else {
print("not greater")
}
# note that an else is the end here, to use another else requires another if
# however, an if does not require an else statement
sign <- function (num) {
if (num > 0){
return (1)
} else if (num == 0) {
return (0)
} else {
return (-1)
}
}
# note that we use "==" in the else if, that is used when we make a logic check
# the "==" is a check that num and 0 are equal to each other
# testing the function
sign(3)
# >  greater than
# <  less than
# ==  is equal to
# >=  greater than OR equal to
# <=  less than OR equal to
# What about when we want two checks before running a command?
num <- 37
num_2 <- 55
if (num <100) {
if (num_2 > 100) {
print("awesome")
}
} else{
print("not awesome")
}
# what about if either condition can be correct to run the command?
if (num < 100 || num_2 >100){
print("awesome")
} else {
print("not awesome")
}
# for complex conditions or clearer writing we can state the condition
# before we have our if else statements
is_correct <- (num < 100 || num_2 >100 && num_2<100)
if (is_correct) {
print("correct!")
} else {
print("incorrect")
}
# Challenge 1
# write a function plot_dist that creates a boxplot if the length of a
# vector is greater than a specified threshold and a stripchart otherwise
# you can use the inbuilt r functions boxplot and stripchart
# To see how they work you can use ?boxplot and ?stripchart
plot_dist <- function(data, threshold) {
if (length(data) > threshold) {
boxplot(x)
} else {
stripchart(x)
}
}
# testing our function
plot_dist(c(1,2,3,4,4), 4)
plot_dist(c(3,4,555,6), 10)
# Challenge 2
file_names <- list.files(path = "data",
pattern = "inflammation",
full.names = TRUE)
# Setting our initial values, ready to be overwritten
file_name_max <- ""
patient_max <- 0
average_inf_max <- 0
for (f in file_names) {
dat <- read.csv(file = f, header = FALSE)
dat_means <- apply(dat, 1, mean) # Applying the mean function per row
# We loop over index values in the range from 1 to the length of dat_means
# We check each patient and look for the maximum average inflammation
# We check all patients keeping the index and file name where the largest
# Average inflammation is
for(patient_index in 1:length(dat_means)) {
patient_average_inf <- dat.means[patient_index]
if (patient_average_inf > average_inf_max) {
average_inf_max <- patient_average_inf
patient_max <- patient_index
file_name_max <- f
}
}
}
# Logic in R
# Logic is needed a lot in writing code
# We can start with the less than and greater than symbols
num <- 37
num < 100
num > 100
num <- 37
if (num > 100) {
print("greater")
} else {
print("not greater")
}
# note that an else is the end here, to use another else requires another if
# however, an if does not require an else statement
sign <- function (num) {
if (num > 0){
return (1)
} else if (num == 0) {
return (0)
} else {
return (-1)
}
}
# note that we use "==" in the else if, that is used when we make a logic check
# the "==" is a check that num and 0 are equal to each other
# testing the function
sign(3)
# >  greater than
# <  less than
# ==  is equal to
# >=  greater than OR equal to
# <=  less than OR equal to
# What about when we want two checks before running a command?
num <- 37
num_2 <- 55
if (num <100) {
if (num_2 > 100) {
print("awesome")
}
} else{
print("not awesome")
}
# what about if either condition can be correct to run the command?
if (num < 100 || num_2 >100){
print("awesome")
} else {
print("not awesome")
}
# for complex conditions or clearer writing we can state the condition
# before we have our if else statements
is_correct <- (num < 100 || num_2 >100 && num_2<100)
if (is_correct) {
print("correct!")
} else {
print("incorrect")
}
# Challenge 1
# write a function plot_dist that creates a boxplot if the length of a
# vector is greater than a specified threshold and a stripchart otherwise
# you can use the inbuilt r functions boxplot and stripchart
# To see how they work you can use ?boxplot and ?stripchart
plot_dist <- function(data, threshold) {
if (length(data) > threshold) {
boxplot(x)
} else {
stripchart(x)
}
}
# testing our function
plot_dist(c(1,2,3,4,4), 4)
plot_dist(c(3,4,555,6), 10)
# Challenge 2
file_names <- list.files(path = "data",
pattern = "inflammation",
full.names = TRUE)
# Setting our initial values, ready to be overwritten
file_name_max <- ""
patient_max <- 0
average_inf_max <- 0
for (f in file_names) {
dat <- read.csv(file = f, header = FALSE)
dat_means <- apply(dat, 1, mean) # Applying the mean function per row
# We loop over index values in the range from 1 to the length of dat_means
# We check each patient and look for the maximum average inflammation
# We check all patients keeping the index and file name where the largest
# Average inflammation is
for(patient_index in 1:length(dat_means)) {
patient_average_inf <- dat_means[patient_index]
if (patient_average_inf > average_inf_max) {
average_inf_max <- patient_average_inf
patient_max <- patient_index
file_name_max <- f
}
}
}
print(file_name_max)
print(patient_max)
# Here we will look at reading and writing different datasets
# We have been using the same dataset for a while, let's check out car-speeds.csv
# if you want to view the data before opening with R you can use the files tab
# in the bottom right window, clicking on the data folder and clicking on
# car-speeds.csv and finally view to open it here in RStudio
# we can see there is a header, so we set header to TRUE this time
car_speeds <- read.csv("data/car-speeds.csv", header = TRUE)
head(car_speeds)
read.csv2("data/car-speeds.csv")
# we use the built in unique function to extract unique colours in the database
unique(car_speeds$Color)
car_speeds <- read.csv("data/car-speeds.csv", header = TRUE, strip.white = TRUE)
unique(car_speeds)
unique(car_speeds$Color)
datNA <- read.csv("data/inflammation-01.csv",
header = FALSE,
na.strings = 0)
datNA
ar_speedsNA <- read.csv("data/car-speeds.csv",
header=TRUE,
strip.white=TRUE,
na.strings = c("Black", "Blue"))
car_speedsNA
car_speedsNA <- read.csv("data/car-speeds.csv",
header=TRUE,
strip.white=TRUE,
na.strings = c("Black", "Blue"))
car_speedsNA
car_speeds <- read.csv(file = "data/car-speeds.csv")
# what type of data is carspeeds?
typeof(car_speeds)
# Objects in R also have classes, to check this we use the class function
class(car_speeds)
# Let's check some text now
x <- "dataset"
typeof(x)
class(x)
# How about when using the range command?
y <- 1:10
typeof(y)
length(y)
# What if we need to change the datatype?
# we can use as.X where X is the datatype to convert to
# for example to numeric
z <- as.numeric(y)
typeof(z)
z
# You can create dataobjects by calling the type
vector()
logical(0)
vector("character", length=5)
numeric(5)
m <- matrix(nrow = 2, ncol = 2)
m[1,1,] <- 6
m <- matrix(nrow = 2, ncol = 2)
m[1,1] <- 6
m
m <-cbind(m, c(4,5))
m
# We can also do this row wise with the row bind, rbind
m <- rbind(m, c(4,5))
m
# As an example we copy the function from the challenge from yesterday
analyze <- function(filename) {
# Plots the average, min, and max inflammation over time.
# Input is character string of a csv file.
dat <- read.csv(file = filename, header = FALSE)
avg_day_inflammation <- apply(dat, 2, mean)
plot(avg_day_inflammation)
max_day_inflammation <- apply(dat, 2, max)
plot(max_day_inflammation)
min_day_inflammation <- apply(dat, 2, min)
plot(min_day_inflammation)
}
file_names <- list.files( path = "data",
pattern = "inflammation",
full.names = TRUE)
a <- 1:100000
b <- 1:100000
# an empty vector to store results
results <- numeric( length = length(a))
for (i in 1:length(a)) {
results[i] <- a[i] + b[i]
}
# Quite slow, right?
#the faster option is
results <- a + b
a <- 1:100000
b <- 1:100000
# an empty vector to store results
results <- numeric( length = length(a))
for (i in 1:length(a)) {
results[i] <- a[i] + b[i]
}
results
# Quite slow, right?
#the faster option is
results <- a + b
results
# As an example we copy the function from the challenge from yesterday
analyze <- function(filename) {
# Plots the average, min, and max inflammation over time.
# Input is character string of a csv file.
dat <- read.csv(file = filename, header = FALSE)
avg_day_inflammation <- apply(dat, 2, mean)
plot(avg_day_inflammation)
max_day_inflammation <- apply(dat, 2, max)
plot(max_day_inflammation)
min_day_inflammation <- apply(dat, 2, min)
plot(min_day_inflammation)
}
file_names <- list.files( path = "data",
pattern = "inflammation",
full.names = TRUE)
# We have used both for loops and apply
# Typically apply is a lot faster, it runs the function in a 'vectorised' form
# A comparison
# two large vectors
a <- 1:100000000
b <- 1:100000000
# an empty vector to store results
results <- numeric( length = length(a))
for (i in 1:length(a)) {
results[i] <- a[i] + b[i]
}
results
# Quite slow, right?
#the faster option is
results <- a + b
results
